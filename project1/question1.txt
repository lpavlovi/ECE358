The program consists of 3 modules, a simulation, a logging module, and a simulation tester module. The simulation module contains a simulation object which takes in all of the necessary parameters: L, C, Lambda, TICKS, and tick length. Creating a new instance of the simulation initializes the values and calculates the server process time from the L and C values. In addition to the attributes required for the simulation, additional attributes are initialized for the performance metrics. The simulation has a run method which executes the simulation with the given parameters and gathers data at every tick increment. The general structure is similar to the example code provided, where the execution starts off with getting a new packet arrival time and converts the value into a discrete time based on the length of the tick. Then the execution enters a for loop which calls the arrival and departure methods and finally records the number of packets in the queue at that given point in time. This is recorded in the packets_in_queue array which spans the entire simulation duration. The arrival method checks if the current tick is equal to the next arrival time, if it is then a new packet is generated and added to the queue. If the queue is empty then the arrival method deals with adding a new departure time. In the departure method, it also checks if the current tick is at the next departure time. When it reaches the next departure time, the packet is dequeued, the sojourn time is recorded, and if the queue still has packets then the next departure time is set based on the value perviously calculated in the intialization phase. The packets that are endqueued and dequeued are integers that represent the tick value at which they were added into the queue. This allows for a simpler way to gather performance metrics in the dequeue method in comparison to representing the packets as an object. In the implementation, the packet that is being processed by the server is found at the very start of the queue. This results in adjusting the performance metrics so that when the implemented queue has a single packet, it is actually being processed by the server. When the queue has 2 packets then the top one is being processed while the second one is waiting for the server. This resulted in subtracting the amount of packets in the queue by one (if there are more than 0 packets) in order to get the average queue load. Due to this implementation, finding the server idle time was a matter of counting the amount of times that the queue had no packets present.

The simulation runner deals with setting up the appropriate parameters required for the simulations and gathering the results from multiple runs and averaging them out.
